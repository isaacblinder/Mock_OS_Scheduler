import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

public class Scheduler {

	
	public static int loopNum = 0;
	public static int numOfProcesses = 0;
	public static double CPUTot = 0;
	public static double IOTotal = 0;
	public static double jobsCompleted = 0;
	public static double aveTurnaroundTime = 0;
	public static double aveWaitTime = 0;
	
	
	
	//the first-come, first-serve scheduler method
	public static void HPRNscheduler(ArrayList<Process> pList, Scanner sc, int debugger)
	{
	loopNum = 0;	
	numOfProcesses = 0;
	CPUTot = 0;
	IOTotal = 0;
	jobsCompleted = 0;
	aveTurnaroundTime = 0;
	aveWaitTime = 0;
	
		// runningProcess lets the scheduler know if there is currently a process running
		// if there is no process running, runningProcess == -1. Otherwise, runningProcess equals the process number
		// of the running process.
		int runningProcess = -1;
			
	
		//if stop switches to 1, the loop ends
		//this is the main loop
		int stop = 0;
		while(stop == 0)
		{	
		//print the status of each process before each loop
			if(debugger == 1)
				statusPrint(pList, loopNum);	
		
		//this loop updates the process's attributes
		for(int i3 = 0; i3 < pList.size(); i3++)
		{
			Process p = pList.get(i3);
			
			//what to do if P didn't start yet
			if(p.state == 0)
			{
				if(p.A == loopNum)
				{
					p.processNum = numOfProcesses;
					numOfProcesses++;
				p.state = 3;	
				p.readyNum = 0;
				}
				
			}
			
			//what to do if P is running
			else if(p.state == 1)
			{
				//if the CPUBurst is ending
				if(p.loopsLeft <= 1)
				{
					p.state = 2;
					p.loopsLeft = p.CPUBurst * p.M;	
					runningProcess = -1;
					jobsCompleted++;
				}
				
				else
					p.loopsLeft--;
				
				p.totRunningTime++;
				p.CPULeft--;
			}
			
			//what to do if P is blocked
			else if(p.state == 2)
			{
			p.IOTime++;
			
			if(p.loopsLeft <= 1)
			{
				p.state = 3;
				p.readyNum = 0;
			}
			else
				p.loopsLeft--;
				
			}
			
			//what to do if P is ready
			else if(p.state == 3)
			{
			p.waitTime++;
			p.readyNum++;
			}	
			
			//check if it is time for P to terminate
			if(p.CPULeft == 0 && p.state != 4)
			{
				p.state = 4;
				p.finishTime = loopNum;
				aveTurnaroundTime += (loopNum - p.A);
				aveWaitTime += p.waitTime;
			}
			
			//calculate the r value of the process
			p.r = (double)(loopNum - p.A) / Math.max(1,p.totRunningTime);
		}
		
		
			//check if all of the processes have terminated. If so, stop the loop
			int b2 = 0;
			for(int i4 = 0; i4 < pList.size(); i4++)
			{
				Process p2 = pList.get(i4);
				if(p2.state == 4)
					b2++;
			}
			if(b2 == pList.size())
			{
				stop = 1;
				
			}
	
	//if no processes are running, scheduler picks the next process to run (if any)
	//the process that has been in ready for longest goes next 
	if(runningProcess == -1) {
		
		double mostR = -1;
		int getProcess = -1;
		int pnum = pList.size();
		for(int i5 = 0; i5 < pList.size(); i5++)
		{
			
			Process p3 = pList.get(i5);
			
			if(p3.state == 3)
			{
				
				//the Process with the most r is recorded
				if(p3.r > mostR)
				{
				pnum = p3.processNum;
				mostR = p3.r;
				getProcess = i5;	
				}
				
				//if there is a tie, the Process with the lower processNum is recorded		
				if(p3.r == mostR && p3.processNum < pnum)
				{
					pnum = p3.processNum;
					mostR = p3.r;
					getProcess = i5;	
				}
			}
		}
		
		//make sure that at least one process was chosen, otherwise do nothing
		if(getProcess != -1)
		{
			
		Process p = pList.get(getProcess);
		p.state = 1;
		runningProcess = p.processNum;
		
		//creates a random int (0 to limit]
		//if the random number generated by randomOS is larger than the remaining CPU loops
		//left until the process terminates, then set loopsLeft to the number of remaining CPU loops.	
		int randNum = 1 + (sc.nextInt() % p.B);
			if(randNum <= p.CPULeft)
				p.loopsLeft = randNum;
			else
				p.loopsLeft = p.CPULeft;
		p.CPUBurst = p.loopsLeft;
		}
		}



	//update variables for final print
	for(int c = 0; c < pList.size(); c++)
	{
		if(pList.get(c).state == 1)
		{
			CPUTot++;
			break;
		}
	}
	
	for(int c = 0; c < pList.size(); c++)
	{
		if(pList.get(c).state == 2)
		{
			IOTotal++;
			break;
		}
	}
	
	//increment the loop	
	loopNum++;	
		}
	aveTurnaroundTime /= numOfProcesses;
	aveWaitTime /= numOfProcesses;
	}
	
	
	//the first-come, first-serve scheduler method
		public static void FCFSscheduler(ArrayList<Process> pList, Scanner sc, int debugger)
		{
		loopNum = 0;	
		numOfProcesses = 0;
		CPUTot = 0;
		IOTotal = 0;
		jobsCompleted = 0;
		aveTurnaroundTime = 0;
		aveWaitTime = 0;
		
			// runningProcess lets the scheduler know if there is currently a process running
			// if there is no process running, runningProcess == -1. Otherwise, runningProcess equals the process number
			// of the running process.
			int runningProcess = -1;
				
		
			//if stop switches to 1, the loop ends
			//this is the main loop
			int stop = 0;
			while(stop == 0)
			{	
			//print the status of each process before each loop
				if(debugger == 1)
					statusPrint(pList, loopNum);
			
			for(int i3 = 0; i3 < pList.size(); i3++)
			{
				Process p = pList.get(i3);
				
				//what to do if P didn't start yet
				if(p.state == 0)
				{
					if(p.A == loopNum)
					{
						p.processNum = numOfProcesses;
						numOfProcesses++;
					p.state = 3;	
					p.readyNum = 0;
					}
					
				}
				
				//what to do if P is running
				else if(p.state == 1)
				{
					//if the CPUBurst is ending
					if(p.loopsLeft <= 1)
					{
						p.state = 2;
						p.loopsLeft = p.CPUBurst * p.M;	
						runningProcess = -1;
						jobsCompleted++;
					}
					
					else
						p.loopsLeft--;
					
					p.CPULeft--;
				}
				
				//what to do if P is blocked
				else if(p.state == 2)
				{
				p.IOTime++;
				
				if(p.loopsLeft <= 1)
				{
					p.state = 3;
					p.readyNum = 0;
				}
				else
					p.loopsLeft--;
				}
				
				//what to do if P is ready
				else if(p.state == 3)
				{
				p.waitTime++;
				p.readyNum++;
				}	
				
				//check if it is time for P to terminate
				if(p.CPULeft == 0 && p.state != 4)
				{
					p.state = 4;
					p.finishTime = loopNum;
					aveTurnaroundTime += (loopNum - p.A);
					aveWaitTime += p.waitTime;
				}
			}
			
			
				//check if all of the processes have terminated. If so, stop the loop
				int b2 = 0;
				for(int i4 = 0; i4 < pList.size(); i4++)
				{
					Process p2 = pList.get(i4);
					if(p2.state == 4)
						b2++;
				}
				if(b2 == pList.size())
				{
					stop = 1;
					
				}
		
		//if no processes are running, scheduler picks the next process to run (if any)
		//the process that has been in ready for longest goes next 
		if(runningProcess == -1) {
			
			int mostRest = -1;
			int getProcess = -1;
			int pnum = pList.size();
			for(int i5 = 0; i5 < pList.size(); i5++)
			{
				
				Process p3 = pList.get(i5);
				
				if(p3.state == 3)
				{
					
				//the Process with the most time in the ready state is recorded
					if(p3.readyNum > mostRest)
					{
					pnum = p3.processNum;
					mostRest = p3.readyNum;
					getProcess = i5;	
					}
					
					//if there is a tie, the Process with the lower processNum is recorded
					else if(p3.readyNum == mostRest && p3.processNum < pnum)
					{
						pnum = p3.processNum;
						mostRest = p3.readyNum;
						getProcess = i5;	
					}
				
				}
			}
			
			//make sure that at least one process was chosen
			if(getProcess != -1)
			{
			Process p = pList.get(getProcess);
			p.state = 1;
			runningProcess = p.processNum;
			
			//creates a random int (0 to limit]
			//if the random number generated by randomOS is larger than the remaining CPU loops
			//left until the process terminates, then set loopsLeft to the number of remaining CPU loops.	
			int randNum = 1 + (sc.nextInt() % p.B);
				if(randNum <= p.CPULeft)
					p.loopsLeft = randNum;
				else
					p.loopsLeft = p.CPULeft;
			p.CPUBurst = p.loopsLeft;
			}
			}
		
		//update variables for final print
		for(int c = 0; c < pList.size(); c++)
		{
			if(pList.get(c).state == 1)
			{
				CPUTot++;
				break;
			}
		}
		
		for(int c = 0; c < pList.size(); c++)
		{
			if(pList.get(c).state == 2)
			{
				IOTotal++;
				break;
			}
		}

		//increment the loop	
		loopNum++;	
			}
			aveTurnaroundTime /= numOfProcesses;
			aveWaitTime /= numOfProcesses;
		}
		
		
		
		
		
		
		
	
	
	//shortest job first scheduler method
		public static void SJFscheduler(ArrayList<Process> pList, Scanner sc, int debugger)
		{
			
			CPUTot = 0;
			IOTotal = 0;
			jobsCompleted = 0;
		numOfProcesses = 0;
		aveTurnaroundTime = 0;
		aveWaitTime = 0;		
		loopNum = 0;
		
			// runningProcess lets the scheduler know if there is currently a process running
			// if there is no process running, runningProcess == -1. Otherwise, runningProcess equals the process number
			// of the running process.
			int runningProcess = -1;
			
			//if stop switches to 1, the loop ends
			int stop = 0;
			while(stop == 0)
			{	
			//debugger, print the status of each process before each loop
				if(debugger == 1)
					statusPrint(pList, loopNum);
				
			//this is the loop used once all of the processes have begun
			for(int i3 = 0; i3 < pList.size(); i3++)
			{
				Process p = pList.get(i3);
			
			
	
				//what to do if P didn't start yet
				if(p.state == 0)
				{
					if(p.A == loopNum)
					{
						p.processNum = numOfProcesses;
						numOfProcesses++;
						p.readyNum = 0;
						p.state = 3;	
					}
					
				}
				
				//what to do if P is running
				else if(p.state == 1)
				{
					//if the CPUBurst is ending
					if(p.loopsLeft <= 1)
					{
						p.state = 2;
						p.loopsLeft = p.CPUBurst * p.M;	
						runningProcess = -1;
						jobsCompleted++;
					}
					
					else
						p.loopsLeft--;
					
					p.CPULeft--;
				}
				
				//what to do if P is blocked
				else if(p.state == 2)
				{
				p.IOTime++;
				
				if(p.loopsLeft <= 1)
				{
					p.state = 3;
					p.readyNum = 0;
				}
				else
					p.loopsLeft--;
				}
				
				//what to do if P is ready
				else if(p.state == 3)
				{
				p.waitTime++;
				p.readyNum++;
				}	
				
				//check if it is time for P to terminate
				if(p.CPULeft == 0 && p.state != 4)
				{
					p.state = 4;
					p.finishTime = loopNum;
					aveTurnaroundTime += (loopNum - p.A);
					aveWaitTime += p.waitTime;
				}
			}
			
			
				//check if all of the processes have terminated. If so, stop the loop
				int b2 = 0;
				for(int i4 = 0; i4 < pList.size(); i4++)
				{
					Process p2 = pList.get(i4);
					if(p2.state == 4)
						b2++;
				}
				if(b2 == pList.size())
				{
					stop = 1;
					
				}
		
		//if no processes are running, scheduler picks the next process to run (if any)
		//the process that has been in ready for longest goes next 
		if(runningProcess == -1) {
			
			int least = Integer.MAX_VALUE;
			int getProcess = -1;
			int pnum = pList.size();
			for(int i5 = 0; i5 < pList.size(); i5++)
			{
				
				Process p3 = pList.get(i5);
			if(p3.state == 3) {	
				if(p3.CPULeft < least)
				{
					least = p3.CPULeft;
					getProcess = i5;
					pnum = p3.processNum;
					}
				else if(p3.CPULeft == least &&  p3.processNum < pnum)
				{
					least = p3.CPULeft;
					getProcess = i5;
					pnum = p3.processNum;
				}
				
			}
			}
			
			if(getProcess != -1)
			{
			
			Process p = pList.get(getProcess);
			p.state = 1;
			runningProcess = p.processNum;
			
			//creates a random int (0 to limit]
			//if the random number generated by randomOS is larger than the remaining CPU loops
			//left until the process terminates, then set loopsLeft to the number of remaining CPU loops.	
			int randNum = 1+ (sc.nextInt() % p.B);
				if(randNum <= p.CPULeft)
					p.loopsLeft = randNum;
				else
					p.loopsLeft = p.CPULeft;
			p.CPUBurst = p.loopsLeft;
			}
			}
		
		//update variables for final print
		for(int c = 0; c < pList.size(); c++)
		{
			if(pList.get(c).state == 1)
			{
				CPUTot++;
				break;
			}
		}
		
		for(int c = 0; c < pList.size(); c++)
		{
			if(pList.get(c).state == 2)
			{
				IOTotal++;
				break;
			}
		}
		
		//increment the loop	
		loopNum++;	
			}
			aveTurnaroundTime /= numOfProcesses;
			aveWaitTime /= numOfProcesses;
		}
		
		
		
		
		//the round robin scheduler method
		public static void RRscheduler(ArrayList<Process> pList, Scanner sc, int debugger)
		{
			CPUTot = 0;
			IOTotal = 0;
			jobsCompleted = 0;
		numOfProcesses = 0;
		final int quantum = 2;
		loopNum = 0;	
		aveTurnaroundTime = 0;
		aveWaitTime = 0;
		
			// runningProcess lets the scheduler know if there is currently a process running
			// if there is no process running, runningProcess == -1. Otherwise, runningProcess equals the process number
			// of the running process.
			int runningProcess = -1;

			
			//if stop switches to 1, the loop ends
			int stop = 0;
			while(stop == 0)
			{	
			//print the status of each process before each loop if debugger is on
				if(debugger == 1)
					statusPrint(pList, loopNum);
				
			//this is the loop used once all of the processes have begun
			for(int i3 = 0; i3 < pList.size(); i3++)
			{
				Process p = pList.get(i3);
				
				//what to do if P didn't start yet
				if(p.state == 0)
				{
					if(p.A == loopNum)
					{
					p.processNum = numOfProcesses;
					numOfProcesses++;
					p.state = 3;	
					}	
				}
				
				//what to do if P is running
				else if(p.state == 1)
				{
					p.CPUBurstTime++;
					//if the CPUBurst is ending
					if(p.loopsLeft <= 1)
					{
						p.state = 2;
						p.loopsLeft = p.CPUBurst * p.M;	
						runningProcess = -1;
						p.preempted = 0;
						jobsCompleted++;
					}
					
					//check if the time in CPU is longer than quantum
					else if(p.CPUBurstTime >= quantum)
					{
						p.state = 3;
						runningProcess = -1;
						p.readyNum = 0;
						p.preempted = 1;
						p.loopsLeft--;
						p.CPUBurstTime = 0;
					}
					
					
					else
						p.loopsLeft--;
					
					
					p.CPULeft--;
					
				}
				
				//what to do if P is blocked
				else if(p.state == 2)
				{
				p.IOTime++;
				
				if(p.loopsLeft <= 1)
				{
					p.state = 3;
					p.readyNum = 0;
				}
				else
					p.loopsLeft--;
				}
				
				//what to do if P is ready
				else if(p.state == 3)
				{
				p.waitTime++;
				p.readyNum++;
				}	
				
				//check if it is time for P to terminate
				if(p.CPULeft == 0 && p.state != 4)
				{
					p.state = 4;
					p.finishTime = loopNum;
					aveTurnaroundTime += (loopNum - p.A);
					aveWaitTime += p.waitTime;
				}
			}
			
			
				//check if all of the processes have terminated. If so, stop the loop
				int b2 = 0;
				for(int i4 = 0; i4 < pList.size(); i4++)
				{
					Process p2 = pList.get(i4);
					if(p2.state == 4)
						b2++;
				}
				if(b2 == pList.size())
				{
					stop = 1;
					
				}
		
		//if no processes are running, scheduler picks the next process to run (if any)
		//the process that has been in ready state for longest goes next 
		if(runningProcess == -1) {
			
			int mostRest = -1;
			int getProcess = -1;
			int pnum = pList.size();
			for(int i5 = 0; i5 < pList.size(); i5++)
			{
				
				Process p3 = pList.get(i5);
				
				if(p3.state == 3)
				{
					
				
					if(p3.readyNum > mostRest)
					{
					pnum = p3.processNum;
					mostRest = p3.readyNum;
					getProcess = i5;	
					}
					else if(p3.readyNum == mostRest && p3.processNum < pnum)
					{
						pnum = p3.processNum;
						mostRest = p3.readyNum;
						getProcess = i5;	
					}
				
				}
			}
			
			if(getProcess != -1)
			{
			Process p = pList.get(getProcess);
			p.state = 1;
			runningProcess = p.processNum;
			
			//creates a random int (0 to limit]
			//if the random number generated by randomOS is larger than the remaining CPU loops
			//left until the process terminates, then set loopsLeft to the number of remaining CPU loops.	
			
			//only assign a new CPUBurst if the process wasn't preempted
			if(p.preempted == 0)
			{
			int randNum = 1+ (sc.nextInt() % p.B);
				if(randNum > p.CPULeft)
					p.loopsLeft = p.CPULeft;
				else
					p.loopsLeft = randNum;
	
			p.CPUBurst = p.loopsLeft;
			p.CPUBurstTime = 0;
			}
			}
			}
		
		//update variables for final print
		for(int c = 0; c < pList.size(); c++)
		{
			if(pList.get(c).state == 1)
			{
				CPUTot++;
				break;
			}
		}
		
		for(int c = 0; c < pList.size(); c++)
		{
			if(pList.get(c).state == 2)
			{
				IOTotal++;
				break;
			}
		}

		//increment the loop	
		loopNum++;	
			}
			aveTurnaroundTime /= numOfProcesses;
			aveWaitTime /= numOfProcesses;
		}

	//error check print
	public static void statusPrint(ArrayList<Process> pList, int cycleNum)
	{
		System.out.print("Before cycle " + cycleNum + ": \t");
		for(int i = 0; i < pList.size(); i++)
		{
			Process p = new Process();
			for(int j = 0; j < pList.size(); j++)
			{
				if(i == pList.get(j).processNum) 
					p = pList.get(j);			
			}
			if(p.state == 0)
			{
				System.out.print("unstarted " + 0 + ". \t");
			}
			else if(p.state == 1)
			{
				System.out.print("running " + p.loopsLeft + ". \t");
			}
			else if(p.state == 2)
			{
				System.out.print("blocked " + p.loopsLeft + ". \t");
			}
			else if(p.state == 3)
			{
				System.out.print("ready " + 0 + ". \t");
			}
			else if(p.state == 4)
			{
				System.out.print("terminated " + 0 + ". \t");
			}		
		}
		System.out.println("\n");
	}
	
	//the final print, a summary of the Processes
	public static void finalPrint(ArrayList<Process> pList, int type)
	{
		System.out.println("");
		if(type == 0)
		{
			System.out.println("---------- First Come First Served ----------");
		}
		else if(type == 1)
		{
			System.out.println("---------- Shortest Job First ----------");
		}
		else if(type == 2)
		{
			System.out.println("---------- Round Robin ----------");
		}
		else if(type == 3)
		{
			System.out.println("---------- Highest Penalty Ratio First ----------");
		}
		
		for(int i = 0; i < pList.size(); i++)
		{
			Process p = new Process();
			for(int j = 0; j < pList.size(); j++)
			{
				if(i == pList.get(j).processNum) 
					p = pList.get(j);			
			}
			
			System.out.println("Process " + p.processNum + ":");
			System.out.println( "\t (A,B,C,M) = (" + p.A + ", " + p.B + ", " + p.C + ", " + p.M + ")" );
			System.out.println("\t Finishing time: " + p.finishTime);
			System.out.println("\t Turnaround time: " + (p.finishTime - p.A));
			System.out.println("\t I/O time: " + p.IOTime);
			System.out.println("\t Waiting time: " + p.waitTime);
			System.out.println("");	
		}
		
		System.out.println("Summary Data: ");
		System.out.println("\t Finishing time: " + (loopNum - 1));
		System.out.println("\t CPU Utilization: " + (double)(CPUTot / (loopNum-1)));
		System.out.println("\t I/O Utilization: " + (double)(IOTotal / (loopNum-1)));
		System.out.println("\t Throughput (per 100 loops): " + (double)((numOfProcesses) * 100) / (double)(loopNum-1));
		System.out.println("\t Average Turnaround Time: " + aveTurnaroundTime);
		System.out.println("\t Average Waiting Time: " + aveWaitTime);
		System.out.println("\n");
		System.out.println("\n");
		System.out.println("\n");
	}
	
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub		
		File f;
		//debugger, 0 == do not show
		int deBugger = 0;
		if(args[0].equals("--verbose"))
		{
			deBugger = 1;
			f = new File(args[1]);
		}
		else
			f = new File(args[0]);
		
		 
		try {
			
			
			for(int j = 0; j < 4; j++)
			{
				ArrayList<Process> processList = new ArrayList<Process>();
				
			File randDoc = new File("RandomInts.txt");
			Scanner sc = new Scanner(randDoc);
			
			Scanner input = new Scanner(f);
			int numProcesses = input.nextInt();
			int i = 0;
			while(i < numProcesses)
			{
			Process p = new Process();
			p.A = input.nextInt();
			p.B = input.nextInt();
			p.C = input.nextInt();
			p.M = input.nextInt();
			p.CPULeft = p.C;
			processList.add(p);
			
			i++;
			}
			
			
			
			
			//which loop it is determines which type of scheduler is used
			if(j == 0) {
			FCFSscheduler(processList, sc, deBugger);
			}		
			else if(j == 1) {
			SJFscheduler(processList, sc, deBugger);
			}
			else if(j == 2) {
			RRscheduler(processList, sc, deBugger);
			}
			else if(j == 3) {
			HPRNscheduler(processList, sc, deBugger);
			}
			
			
			finalPrint(processList, j);
			input.close();
			}
		} 
		
		catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
}
